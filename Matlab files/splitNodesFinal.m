%% Splitting nodes test network
% Goal: generate network data using the 3 node system, then identify it
% with splitting nodes.
%
% Generated by Job Meijer with aid of Shengling Shi, February 2020
%
clear all; close all; clc

%% Settings
N = 1000;           % Data length (samples)
Ts = 1;             % Sample time
var_e = 0.1;        % Variance of noise signals e1 and e2
var_r = 1;          % Variance of reference signal r1

% Plot the estimated dynamics and real network dynamics G
plotEstG = true;

% Converting dynamics to topology identification threshold
threshold = 5 % [1 2 3 4 5 6 7 8 9 10];

% Number of different realizations
nRealizations = 1 %50;

%% Determined network structure of 3 node system
% Creating needed symbols
syms w1 w2 w3 'real';
syms e1 e2 'real';
syms r1 'real';
syms G12 G13 G23 G21 G31 G32 'real';
syms H11 H22 H21 H13 'real';

% Creating needed dynamic network representation vectors and matrices
w = [w1 w2 w3]';
e = [e1 e2]';
r = [r1 0 0]';
G = [0 0 0; G21 0 0; G31 0 0];
H = [H11 H21; 0 H22; H13 0];
R = zeros(3,3);
R(1,1) = 1;

% Combine into dynamic network representation
w_ = G*w + H*e + R*r;

% pre-define z
z = tf('z',Ts);

% Set armax options
opt = armaxOptions;
opt.Display = 'off';

% Determined transfer functions of G
G12 = 0;
G13 = 0;
G21 = (-0.2264*z - 0.1613)/(z^2 - 0.9692*z + 0.3673);
G31 = (-0.2264*z - 0.1613)/(z^2 - 0.9692*z + 0.3673);
G32 = 0;
G23 = 0;

% Combine in G matrix
G = [0, G12, G13;
    G21 0 G23;
    G31 G32 0];

% Determine transfer functions of H
% NOTE: H11 and H21 must be strictly proper, otherwise there is correlation between H and
% G resulting in a not identifiable network!
H11 = 1/(z^2 - 0.9692*z + 0.3673);
H22 = 1;
H21 = 1/(z^2 - 0.9692*z + 0.3673);
H13 = 1;
H = [H11 H21; 0 H22; H13 0];

% Set original G topology for determining TPR and FPR
G_original = [0 0 0; 1 0 0; 1 0 0];

% Vary the threshold
for Treshold2norm = threshold
    
    % Vary different realizations
    for realization = 1:nRealizations
        %% Create measurement data for determined network
        % Create noise data (NOT available as measurement for identification)
        e1 = sqrt(var_e).*randn(N,1);
        e2 = sqrt(var_e).*randn(N,1);
        
        % Create input signals (available as measurement for identification)
        r1 = sqrt(var_r).*randn(N,1);
        
        % Generate noise signals (NOT available as measurement for identification)
        v1 = lsim(H11,e1) + lsim(H21,e2);       % Noise input node w1
        v2 = e2;                                % Noise input node w2
        v3 = e1;                                % Noise input node w3
        
        % Excite system with generated data (running simulation)
        w1 = r1 + v1;
        w2 = lsim(G21,w1) + v2;
        w3 = lsim(G31,w1) + v3;
        
        %% Use generated data to identify a model using split node theory - MISO approach
        % Estimation strategy:
        % 1) start with w2, estimate noise signal e2
        % 2) identify w3, estimate noise signal e1
        % 3) identify w1 using estimated noise signals e1 and e2
        
        % 1)
        %
        % Estinate transfers between nodes using MISO approach
        G21_id = iddata(w2,[w1 w3],Ts);
        G31_id = iddata(w3,[w1 w2],Ts);
        
        % estimate w2
        G21_est = armax(G21_id,'na',4,'nb',[4 4],'nc',2,'nk',[1 1],opt);
        G23_est = G21_est(1,2);
        G21_est = G21_est(1,1);
        
        % estimate noise v2: H22*e2
        e2_hat = w2 - lsim(G21_est,w1) - lsim(G23_est,w3);
        
        % 2)
        %
        % Estimate w3
        G31_est = armax(G31_id,'na',4,'nb',[4 4],'nc',2,'nk',[1 1],opt);
        G32_est = G31_est(1,2);
        G31_est = G31_est(1,1);
        
        % estimate noise v3
        e1_hat = w3 - lsim(G31_est,w1) - lsim(G32_est,w2);
        
        % 3)
        %
        % Left with non diagonal part
        w1x = w1 - r1 - lsim(H11,e1_hat) - lsim(H21,e2_hat);
        G12_id = iddata(w1x,[w2 w3],Ts);
        
        % G12_est_M = armax(G12_id_M,'na',4,'nb',[4 4],'nc',2,'nk',[1 1],opt);
        G12_est = armax(G12_id,'na',4,'nb',[4 4],'nc',0,'nk',[1 1],opt);
        G13_est = G12_est(1,2);
        G12_est = G12_est(1,1);
        
        % Determined transfer function MISO approach
        G_est = [0, G12_est, G13_est;
            G21_est, 0, G23_est;
            G31_est, G32_est, 0];
        
        %% Thresholding
        [m,n] = size(G);
        estimatedTopology = zeros(m,n);
        
        for i = 1:m
            for j = 1:n
                [vect2,~,~] = bode(G_est(i,j));     % Compute gain
                Vect2norm = vecnorm(vect2);         % Determine 2-norm of gain
                
                if (Vect2norm > Treshold2norm)      % Check if 2-norm is above threshold
                    estimatedTopology(i,j) = 1;
                end
            end
        end
        
        % Output estimated topology
        estimatedTopology = estimatedTopology
        
        % Determine TPR and FPR ratios
        L = m;
        graphvector = reshape(estimatedTopology,[L^2,1]);
        truth = reshape(G_original,[L^2,1]);
        CP = classperf(truth, graphvector,'Positive', 1, 'Negative', 0);
        TP = CP.DiagnosticTable(1,1);
        P = sum(CP.DiagnosticTable(:,1));
        FP = CP.DiagnosticTable(1,2);
        Ne = sum(CP.DiagnosticTable(:,2));
        TPR = TP/P;
        FPR = FP/Ne;
        
        %% Plot transfer functions G
        if plotEstG
            figure()
            bodemag(G_est)
            hold on
            bodemag(G)
            hold off
            grid on
        end
        
        %% Output realization number
        realization = realization
        TPRvect(realization) = TPR;
        FPRvect(realization) = FPR;
    end
    
    meanTPR = mean(TPRvect)
    meanFPR = mean(FPRvect)
    distance = sqrt(mean(FPRvect)^2+(1-mean(TPRvect))^2)
    
    figure(14)
    hold all
    plot(meanFPR,meanTPR,'*')
    grid on
    xlabel('FPR')
    ylabel('TPR')
    title(['Average TPR/FPR over ', num2str(nRealizations),' realizations of 3 node test network'])
    xlim([0 1])
    ylim([0 1])
end

legend('1','2','3','4','5','6','7','8','9','10','Location','Best')